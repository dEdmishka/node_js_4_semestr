# explanations to code

> ## task 1
> Це звичайна рекурсивна функція, в яку при першому виклику формується початкове значення
> суми, а при кожному наступному параметр передається вкладеній функції, яка додає цей параметр до 
> загальної суми. Для отримання результату викликаємо функцію ще раз (і не передаємо ніяких параметрів), 
> і вона повертає суму.
> 
> Також в переданих параметрах враховується тільки перше число, а масив і об'єкт не прийметься.
> І не можна пропускати один виклик з не переданим параметром, тобто при такому виклику
> >`console.log(add(2)(5)()(11)());`
> 
> буде помилка(ми повертаємо суму, функція відпрацювала, а потім ми пробуємо ще запихнути в функцію 
> параметри)
> 
>---
> 
> ## task 2
> Що таке анаграма? Це  переставлення літер у слові, завдяки чому утворюється нове значення
> Точного і абсолютного значення анаграми я не знайшов, тобто можливий варіант коли ми переставляємо 
> рівну кількість літер, щоб отримати нове слово, і є варіант коли ми повинні точно дотримуватися однакової 
> кількості літер як в початковому слові, так і в його анаграмі. Саме тому я маю дві реалізації:
> 1. Яка враховує довжину строки та однакову кількість літер
> 2. Яка враховує тільки наявність однакових літер 
> 
> В першій функції ми після перевірки на тип вхідного аргументу (строка) та порівняння довжин строк (однакові)
> відбувається наступне:
> - приведення строки(далі - str) до меншого регістру
> - прибирання за допомогою regex-виразу всіх символів у str, окрім літер англійського алфавіту
> - розділення str в масив за допомогою split
> - сортування масиву
> - перетворення відсортованого масиву назад в строку
> - повернення результату порівняння відсортованих строк
> 
> В другій функції ми юзаємо Map, так як з ним вкрай зручно працювати. Після перевірки
> на тип вхіжних аргументів ми ітеруємо першу строку і для кожної літери складамо пару "ключ - значення",
> неважливим тут є значення, нам треба ключ. Головною перевагою тут є, що наш ключ не може повторюватися,
> тобто ми один раз зафіксували певну літеру і більше не звертаємо на неї увагу. В наступному циклі ми
> кожному ключу (символу), який збігається із зафіксованими ключами, ми присвоюємо check
> (будь-що відмінне від value). І в кінці перевірка - якщо щось не попало під check, функція повертає
> false. Отже суть даної функції в тому, що нам неважлива кількість символів, важлива лиш їх наявність.
> 
> ---
> 
> ## task 3
> І сказати по коду нічого. Просте і зрозуміле перетворення об'єкта в строку, і строку в новий об'єкт, який
> аж ніяк не пов'язаний з попереднім об'єктом, з якого його скопіювали. 
> 
> ---
> 
> ## task 4
> Функція-обгортка працює наступним чином:
> 
> Вона приймає на вході функцію, яка буде обраховувати значення. Коли ми передаємо агрументи
> , вона їх запам'ятовує в об'єкті у вигляді ключа і якщо ці значення ще не були обраховані, тобто
> val = null, ми передаємо аргументи функції, що обраховує і повертає вихідне значення, яке ми відразу записуємо
> у значення цього ключа. При наступному виклику йде така сама перевірка, чи не існує такий ключ з вже порахованим значенням, і 
> якщо так, повертаємо його з пам'яті, не прораховуючи знову.